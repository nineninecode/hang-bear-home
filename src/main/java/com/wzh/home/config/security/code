//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.foresealife.iam.client.filter.security;

import com.foresealife.iam.client.api.IamServiceFactory;
import com.foresealife.iam.client.bean.IamPrincipal;
import com.foresealife.iam.client.bean.IamSubject;
import com.foresealife.iam.client.cache.AccCache;
import com.foresealife.iam.client.cache.AccCacheEntity;
import com.foresealife.iam.client.config.IamConfig;
import com.foresealife.iam.client.config.IamConfigFactory;
import com.foresealife.iam.client.filter.security.impl.DefaultRoleProvider;
import com.foresealife.iam.client.util.ClassUtils;
import com.foresealife.iam.client.util.StringUtils;
import com.foresealife.iam.client.util.http.HttpGetServletPath;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import repack.org.springframework.util.AntPathMatcher;

public class RoleBasedAclFilter implements Filter {
    public static final String ANY_METHOD = "*";
    private static IamConfig config = IamConfigFactory.getInstance().getConfig();
    private static AccCache accCache = AccCache.getInstance();
    private AntPathMatcher pathMatcher;
    private AccessControl accessControl;
    private RoleProvider roleProvider;
    private List<String> ignoreRquestSuffix = new ArrayList();
    private List<String> ignoreRquestUrl = new ArrayList();

    public RoleBasedAclFilter() {
    }

    public void init(FilterConfig config) throws ServletException {
        this.pathMatcher = new AntPathMatcher();
        this.initRoleProvider();
    }

    public void initRoleProvider() throws ServletException {
        try {
            if (StringUtils.isBlank(config.getRoleProvider())) {
                this.roleProvider = new DefaultRoleProvider();
            } else {
                this.roleProvider = (RoleProvider)ClassUtils.load(config.getRoleProvider()).newInstance();
            }

        } catch (Exception var2) {
            throw new ServletException("Failed to load role provider class " + config.getRoleProvider(), var2);
        }
    }

    private void getAccessControl() {
        accCache.doFreshAcl(IamServiceFactory.getInstance().getAclService());
        this.accessControl = AccCacheEntity.getAccessControlCache();
    }

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpServletResponse response = (HttpServletResponse)servletResponse;
        this.getAccessControl();
        this.ignoreRquestUrl = IamServiceFactory.getInstance().getUnitService().getCasIgnoreUrlFromApi();
        if (!this.ignoreRequest(request) && !this.isAuthorized(request)) {
            response.setStatus(403);
            if (!StringUtils.isBlank(config.getErrorPage())) {
                request.getRequestDispatcher(config.getErrorPage()).forward(request, response);
            }
        } else {
            chain.doFilter(servletRequest, servletResponse);
        }

    }

    private boolean isAuthorized(HttpServletRequest request) {
        boolean isAuthorized = false;
        List<Rule> matched = this.findPathMatchedPattern(request);
        if (matched.isEmpty()) {
            isAuthorized = true;
        } else {
            isAuthorized = this.hasAnyRuleAndMethodMatched(request, matched);
        }

        return isAuthorized;
    }

    private boolean hasAnyRuleAndMethodMatched(HttpServletRequest request, List<Rule> matched) {
        boolean isAuthorized = false;
        IamSubject subject = this.roleProvider.getRole(request.getRemoteUser(), config.getCompanyCode(), config.getUnitCode());
        if (subject != null && subject.getPrincipals() != null && !subject.getPrincipals().isEmpty()) {
            Iterator var5 = matched.iterator();

            while(var5.hasNext()) {
                Rule rule = (Rule)var5.next();
                if (this.isRoleAllowed(rule, subject) && this.isMethodAllowed(rule, request.getMethod())) {
                    isAuthorized = true;
                    break;
                }
            }
        }

        return isAuthorized;
    }

    private boolean isMethodAllowed(Rule rule, String method) {
        return "*".equals(rule.getMethod()) || rule.getMethod().equals(method);
    }

    private boolean isRoleAllowed(Rule rule, IamSubject subject) {
        boolean isAllowed = false;
        Iterator var4 = subject.getPrincipals().iterator();

        while(var4.hasNext()) {
            IamPrincipal principal = (IamPrincipal)var4.next();
            if (principal.getAttrValues().contains(rule.getRole())) {
                isAllowed = true;
                break;
            }
        }

        return isAllowed;
    }

    private List<Rule> findPathMatchedPattern(HttpServletRequest request) {
        List<Rule> matched = new ArrayList();
        String requestURI = HttpGetServletPath.getServletPath(request);
        Iterator var4 = this.accessControl.getRules().iterator();

        while(true) {
            Rule rule;
            while(true) {
                if (!var4.hasNext()) {
                    return matched;
                }

                rule = (Rule)var4.next();
                String path = rule.getPath();
                if (this.pathMatcher.isPattern(path)) {
                    if (this.pathMatcher.match(path, requestURI)) {
                        break;
                    }
                } else if (path.equals(requestURI)) {
                    break;
                }
            }

            matched.add(rule);
        }
    }

    private boolean ignoreRequest(HttpServletRequest request) {
        String url = HttpGetServletPath.getServletPath(request);
        if (this.ignoreRquestUrl.contains(url)) {
            return true;
        } else {
            if (url.contains(".")) {
                String suffix = url.substring(url.lastIndexOf(46) + 1);
                if (this.ignoreRquestSuffix.contains(suffix.toLowerCase())) {
                    return true;
                }
            }

            Iterator var5 = this.ignoreRquestUrl.iterator();

            String ignoreUrl;
            do {
                if (!var5.hasNext()) {
                    return false;
                }

                ignoreUrl = (String)var5.next();
            } while(!this.pathMatcher.isPattern(ignoreUrl) || !this.pathMatcher.match(ignoreUrl, url));

            return true;
        }
    }

    public void destroy() {
    }
}
